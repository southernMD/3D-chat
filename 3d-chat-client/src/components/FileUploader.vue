<template>

    <div class="file-uploader">
        <!-- ‰∏ä‰º†ÊåâÈíÆ -->
        <button class="upload-button" @click="showUploadDialog">
            <span class="upload-icon">üìÅ</span>
            <span>{{ $t('modelSelection.uploadModel') }}</span>
        </button>

        <!-- ‰∏ä‰º†ÂØπËØùÊ°Ü -->
        <teleport to="body">
            <div v-if="showUpload" class="upload-dialog-overlay" @click.self="closeUploadDialog">
                <div class="upload-dialog">
                    <div class="upload-header">
                        <h3>{{ $t('modelSelection.uploadDialog.title') }}</h3>
                        <button class="close-btn" @click="closeUploadDialog">√ó</button>
                    </div>
                    <div class="upload-content-wrapper">
                        <!-- Â∑¶‰æß‰∏ä‰º†Âå∫Âüü -->
                        <div class="upload-section">
                            <div class="upload-content">
                                <!-- Âä®‰ΩúÊ£ÄÊµãËíôÁâà -->
                                <div v-if="isDetectingAnimation" class="detection-overlay">
                                    <div class="detection-content">
                                        <div class="loading-spinner"></div>
                                        <p>{{ $t('fileUploader.detectingAnimation') }}</p>
                                    </div>
                                </div>

                                <!-- ÊãñÊãΩ‰∏ä‰º†Âå∫Âüü -->
                                <div class="drag-upload-area"
                                    :class="{ 'drag-over': isDragOver, 'uploading': isUploading }" @drop="handleDrop"
                                    @dragover.prevent="handleDragOver" @dragenter.prevent="handleDragEnter"
                                    @dragleave.prevent="handleDragLeave" @click="triggerFileSelect">
                                    <div class="upload-icon">üìé</div>
                                    <p v-if="!isUploading">{{ $t('fileUploader.dragDrop') }}</p>
                                    <p v-else class="uploading-prompt">Ê≠£Âú®Â§ÑÁêÜÊñá‰ª∂‰∏≠ÔºåËØ∑Á≠âÂæÖ...</p>
                                    <p class="upload-note">{{ $t('fileUploader.supportedFormats') }}</p>
                                    <p class="format-requirements">ÊîØÊåÅ: GLB/GLTF Ê®°ÂûãÊñá‰ª∂, ZIP ÂéãÁº©ÂåÖ(PMX+Á∫πÁêÜ+VMD)</p>
                                    <button class="select-file-btn" @click.stop="triggerFileSelect"
                                        :disabled="isUploading">
                                        {{ $t('fileUploader.selectFiles') }}
                                    </button>
                                </div>

                                <!-- ÈöêËóèÁöÑÊñá‰ª∂ËæìÂÖ• -->
                                <input ref="fileInput" type="file" :multiple="false" :accept="'.glb,.gltf,.zip'"
                                    style="display: none" @change="handleFileSelect" :disabled="isUploading" />

                                <!-- Êñá‰ª∂ÂàóË°®ÂíåËøõÂ∫¶ -->
                                <div v-if="uploadFiles.length > 0" class="upload-list">
                                    <h4 class="list-title">{{ $t('fileUploader.uploadList') }}</h4>

                                    <div class="file-items">
                                        <div v-for="file in uploadFiles" :key="file.id" class="file-item"
                                            :class="{ 'completed': file.status === 'completed', 'error': file.status === 'error' }">
                                            <!-- Êñá‰ª∂‰ø°ÊÅØ -->
                                            <div class="file-info">
                                                <div class="file-icon">
                                                    <span v-if="file.status === 'completed'">‚úÖ</span>
                                                    <span v-else-if="file.status === 'error'">‚ùå</span>
                                                    <span v-else>üìÑ</span>
                                                </div>

                                                <div class="file-details">
                                                    <div class="file-name" :title="file.name">{{ file.name }}</div>
                                                    <div class="file-size">{{ formatFileSize(file.size) }}</div>
                                                </div>
                                            </div>

                                            <!-- ËøõÂ∫¶Êù° -->
                                            <div v-if="file.status === 'uploading' || file.status === 'completed'"
                                                class="progress-container">
                                                <div class="progress-bar">
                                                    <div class="progress-fill" :style="{ width: file.progress + '%' }"
                                                        :class="{ 'completed': file.status === 'completed' }"></div>
                                                </div>
                                                <div class="progress-text">
                                                    {{ file.progress }}%
                                                    <span v-if="file.status === 'uploading'" class="upload-speed">
                                                        ({{ formatSpeed(file.uploadSpeed) }})
                                                    </span>
                                                </div>
                                            </div>

                                            <!-- ÈîôËØØ‰ø°ÊÅØ -->
                                            <div v-if="file.status === 'error'" class="error-message">
                                                {{ file.errorMessage }}
                                            </div>
                                        </div>
                                    </div>

                                    <!-- ÊâπÈáèÊìç‰Ωú -->
                                    <div class="batch-actions">
                                        <button class="batch-btn upload-btn" @click="uploadAllFiles"
                                            :disabled="!canUpload || isUploading || isUploadingDebounce">
                                            <span v-if="isUploadingDebounce">Â§ÑÁêÜ‰∏≠...</span>
                                            <span v-else>{{ $t('fileUploader.upload') }}</span>
                                        </button>

                                        <button class="batch-btn cancel-btn" @click="cancelUpload"
                                            :disabled="!isUploading">
                                            ÂèñÊ∂à‰∏ä‰º†
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Âè≥‰æß‰ø°ÊÅØË°®Âçï -->
                        <div class="info-section">
                                <div class="info-form">
                                    <h4 class="form-title">Ê®°Âûã‰ø°ÊÅØ</h4>

                                    <!-- Ê®°ÂûãÈ¢ÑËßà -->
                                    <div class="form-group">
                                        <label class="form-label">Ê®°ÂûãÈ¢ÑËßà <span class="required">*</span></label>
                                        <div class="model-preview-area"
                                            :class="{ 'has-model': hasModelLoaded }">

                                            <div class="model-preview-container">
                                                <canvas ref="modelCanvas" class="model-canvas" 
                                                    :style="{ display: hasModelLoaded ? 'block' : 'none' }"></canvas>
                                                <div v-if="hasModelLoaded" class="model-overlay">
                                                    <div class="model-controls">
                                                        <button type="button" class="control-btn reset-btn"
                                                            @click="resetModelView" title="ÈáçÁΩÆËßÜËßí">üîÑ</button>
                                                    </div>
                                                </div>
                                                
                                                <div v-if="!hasModelLoaded" class="model-upload-prompt">
                                                    <div class="upload-icon">üéØ</div>
                                                    <p>ËØ∑ÂÖàÈÄâÊã©Ê®°ÂûãÊñá‰ª∂</p>
                                                    <p class="upload-note">Â∞Ü‰ºöËá™Âä®Âä†ËΩΩÈ¢ÑËßà</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Ê®°ÂûãÂêçÁß∞ -->
                                    <div class="form-group">
                                        <label class="form-label">Ê®°ÂûãÂêçÁß∞ <span class="required">*</span></label>
                                        <input v-model="modelInfo.name" type="text" class="form-input"
                                            placeholder="ËØ∑ËæìÂÖ•Ê®°ÂûãÂêçÁß∞" maxlength="50" />
                                        <div class="input-hint">{{ modelInfo.name.length }}/50</div>
                                    </div>

                                    <!-- Ê®°ÂûãÂ§ßÂ∞è -->
                                    <div class="form-group">
                                        <label class="form-label">Ê®°ÂûãÂ§ßÂ∞è</label>
                                        <div class="size-display">
                                            <div class="size-item">
                                                <span>Êñá‰ª∂Â§ßÂ∞è:</span>
                                                <span>{{ formatFileSize(modelInfo.fileSize) }}</span>
                                            </div>
                                            <div class="size-item">
                                                <span>Ê†ºÂºè:</span>
                                                <span>{{ modelInfo.format }}</span>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Ê®°ÂûãÊèèËø∞ -->
                                    <div class="form-group">
                                        <label class="form-label">Ê®°ÂûãÊèèËø∞</label>
                                        <textarea v-model="modelInfo.description" class="form-textarea"
                                            placeholder="ËØ∑ÊèèËø∞ÊÇ®ÁöÑÊ®°ÂûãÁâπËâ≤„ÄÅÁî®ÈÄîÊàñËÆæËÆ°ÁêÜÂøµ..." maxlength="500" rows="4"></textarea>
                                        <div class="input-hint">{{ modelInfo.description.length }}/500</div>
                                    </div>

                                </div>
                        </div>
                    </div>
                </div>
            </div>
        </teleport>
    </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue'
import { MMDLoader } from 'three/examples/jsm/loaders/MMDLoader.js'
import { useI18n } from 'vue-i18n'
import JSZip from 'jszip'
import * as THREE from 'three'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import { showError, showInfo, showSuccess, showWarning } from '@/utils/message';
import { calculateFileHash } from '@/utils/fileHash';
import { useAuthStore } from '@/stores/auth';

// Á±ªÂûãÂÆö‰πâ
interface UploadFile {
    id: string
    name: string
    size: number
    file: File
    status: 'pending' | 'uploading' | 'completed' | 'error'
    progress: number
    uploadSpeed: number
    errorMessage?: string
    startTime?: number
}

// Props
interface Props {
    accept?: string
    multiple?: boolean
    maxFileSize?: number // MB
}

const props = withDefaults(defineProps<Props>(), {
    accept: '.glb,.gltf,.zip',
    multiple: false,
    maxFileSize: 500,
})

// Emits
const emit = defineEmits<{
    fileSelected: [files: File[]]
    uploadProgress: [file: UploadFile]
    uploadCompleted: [file: UploadFile]
    uploadError: [file: UploadFile, error: string]
    allUploadsCompleted: [files: UploadFile[]]
}>()

// Composables
const { t } = useI18n()
const authStore = useAuthStore()

// Refs
const fileInput = ref<HTMLInputElement | null>(null)
const uploadFiles = ref<UploadFile[]>([])
const isDragOver = ref(false)
const showUpload = ref(false)
const isDetectingAnimation = ref(false)
const currentModelType = ref<'glb' | 'gltf' | 'pmx' | null>(null)
const waitingForVmd = ref(false)
const isUploading = ref(false)
const currentXHR = ref<XMLHttpRequest | null>(null) // ‰øùÂ≠òÂΩìÂâçÁöÑxhrÂºïÁî®
const abortController = ref<AbortController | null>(null) // Áî®‰∫éÂèñÊ∂àhashËÆ°ÁÆóÂíåÂéãÁº©
const currentWorkers = ref<Worker[]>([]) // ‰øùÂ≠òÂΩìÂâçËøêË°åÁöÑWorkers
const activeURLs = ref<string[]>([]) // ‰øùÂ≠òÊâÄÊúâÂàõÂª∫ÁöÑURLÂØπË±°ÔºåÁî®‰∫éÊ∏ÖÁêÜ

// Ê®°ÂûãÈ¢ÑËßàÁõ∏ÂÖ≥
const modelCanvas = ref<HTMLCanvasElement | null>(null)
const hasModelLoaded = ref(false)
const modelInfo = ref({
    name: '',
    description: '',
    fileSize: 0,
    format: ''
})

// Three.js Áõ∏ÂÖ≥
let scene: THREE.Scene | null = null
let camera: THREE.PerspectiveCamera | null = null
let renderer: THREE.WebGLRenderer | null = null
let controls: OrbitControls | null = null
let currentModel: THREE.Group | null = null
let animationFrameId: number | null = null

// Computed
const hasUploadableFiles = computed(() =>
    uploadFiles.value.some(file => file.status === 'pending' || file.status === 'error')
)

const hasCompletedFiles = computed(() =>
    uploadFiles.value.some(file => file.status === 'completed')
)

const canUpload = computed(() => {
    return hasUploadableFiles.value
})

// ÊñπÊ≥ï
const showUploadDialog = () => {
    // ÊâìÂºÄÂºπÁ™óÂâçÂÖàÊ∏ÖÁêÜ‰πãÂâçÁöÑËµÑÊ∫ê
    performResourceCleanup()
    resetUploadState()
    showUpload.value = true
    console.log('üìÇ ‰∏ä‰º†ÂºπÁ™óÂ∑≤ÊâìÂºÄÔºåËµÑÊ∫êÂ∑≤Ê∏ÖÁêÜ')
}

const triggerFileSelect = () => {
    // Â¶ÇÊûúÊ≠£Âú®‰∏ä‰º†Ôºå‰∏çÂÖÅËÆ∏ÈÄâÊã©Êñá‰ª∂
    if (isUploading.value) {
        showWarning('‰∏ä‰º†ËøáÁ®ã‰∏≠‰∏çÂÖÅËÆ∏Ê∑ªÂä†Êñá‰ª∂')
        return
    }
    fileInput.value?.click()
}

// ÊãñÊãΩ‰∫ã‰ª∂Â§ÑÁêÜ
const handleDragOver = (event: DragEvent) => {
    event.preventDefault()
    // Â¶ÇÊûúÊ≠£Âú®‰∏ä‰º†Ôºå‰∏çÂÖÅËÆ∏ÊãñÊãΩ
    if (isUploading.value) {
        return
    }
    isDragOver.value = true
}

const handleDragEnter = (event: DragEvent) => {
    event.preventDefault()
    // Â¶ÇÊûúÊ≠£Âú®‰∏ä‰º†Ôºå‰∏çÂÖÅËÆ∏ÊãñÊãΩ
    if (isUploading.value) {
        return
    }
    isDragOver.value = true
}

const handleDragLeave = (event: DragEvent) => {
    event.preventDefault()
    // Â¶ÇÊûúÊ≠£Âú®‰∏ä‰º†Ôºå‰∏çÂ§ÑÁêÜÊãñÊãΩ‰∫ã‰ª∂
    if (isUploading.value) {
        return
    }
    // Âè™ÊúâÂΩìÁ¶ªÂºÄÊï¥‰∏™ÊãñÊãΩÂå∫ÂüüÊó∂ÊâçÂèñÊ∂àÈ´ò‰∫Æ
    const rect = (event.currentTarget as HTMLElement).getBoundingClientRect()
    if (
        event.clientX < rect.left ||
        event.clientX > rect.right ||
        event.clientY < rect.top ||
        event.clientY > rect.bottom
    ) {
        isDragOver.value = false
    }
}

const handleDrop = (event: DragEvent) => {
    event.preventDefault()
    isDragOver.value = false

    // Â¶ÇÊûúÊ≠£Âú®‰∏ä‰º†Ôºå‰∏çÂÖÅËÆ∏Ê∑ªÂä†Êñá‰ª∂
    if (isUploading.value) {
        showWarning('‰∏ä‰º†ËøáÁ®ã‰∏≠‰∏çÂÖÅËÆ∏Ê∑ªÂä†Êñá‰ª∂')
        return
    }

    const files = Array.from(event.dataTransfer?.files || [])
    if (files.length > 0) {
        processFiles(files)
    }
}

const handleFileSelect = (event: Event) => {
    // Â¶ÇÊûúÊ≠£Âú®‰∏ä‰º†Ôºå‰∏çÂÖÅËÆ∏Ê∑ªÂä†Êñá‰ª∂
    if (isUploading.value) {
        showWarning('‰∏ä‰º†ËøáÁ®ã‰∏≠‰∏çÂÖÅËÆ∏Ê∑ªÂä†Êñá‰ª∂')
        return
    }

    const target = event.target as HTMLInputElement
    const files = Array.from(target.files || [])

    if (files.length > 0) {
        processFiles(files)
    }

    // Ê∏ÖÁ©∫input
    if (target) target.value = ''
}

const processFiles = async (files: File[]) => {
    if (files.length === 0) return

    // ÂçïÊñá‰ª∂‰∏ä‰º†ÈôêÂà∂
    if (files.length > 1) {
        showWarning(t('fileUploader.singleFileOnly'))
        return
    }

    const file = files[0]
    const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase()

    // PMX Ê®°ÂûãÂøÖÈ°ªÊòØ ZIP Ê†ºÂºè
    if (fileExtension === '.pmx') {
        showError('PMX Ê®°ÂûãÂøÖÈ°ª‰ª• ZIP ÂéãÁº©ÂåÖÊ†ºÂºè‰∏ä‰º†ÔºåÂéãÁº©ÂåÖÂÜÖÈúÄÂåÖÂê´ .pmx Êñá‰ª∂„ÄÅË¥¥ÂõæÊñá‰ª∂(.png)ÂíåÂä®‰ΩúÊñá‰ª∂(.vmd)')
        return
    }

    // Ê£ÄÊü•ÊòØÂê¶‰∏∫VMDÊñá‰ª∂
    if (fileExtension === '.vmd') {
        showError('VMD Êñá‰ª∂Â∫îËØ•‰∏é PMX Ê®°Âûã‰∏ÄËµ∑ÊâìÂåÖÂú® ZIP Êñá‰ª∂‰∏≠‰∏ä‰º†')
        return
    }

    // ÈÄâÊã©Êñ∞ÁöÑglb/gltf/zipÊñá‰ª∂Êó∂ÔºåËá™Âä®Ê∏ÖÁ©∫Â∑≤ÊúâÂàóË°®
    if (fileExtension === '.glb' || fileExtension === '.gltf' || fileExtension === '.zip') {
        uploadFiles.value = []
        resetUploadState()
    }

    // È™åËØÅÊñá‰ª∂
    if (!validateFile(file)) {
        return
    }

    // Â§ÑÁêÜ ZIP Êñá‰ª∂
    if (fileExtension === '.zip') {
        try {
            showSuccess('Ê≠£Âú®Ëß£Êûê ZIP Êñá‰ª∂...')
            const zipContents = await parseZipFile(file)
            
            if (!zipContents.pmxFile) {
                showError('ZIP Êñá‰ª∂‰∏≠Êú™ÊâæÂà∞ PMX Ê®°ÂûãÊñá‰ª∂ÔºåÊó†Ê≥ï‰∏ä‰º†')
                return
            }

            // ËÆæÁΩÆÊ®°ÂûãÁ±ªÂûã‰∏∫ PMX
            currentModelType.value = 'pmx'

            // Ê∑ªÂä† PMX Êñá‰ª∂Âà∞‰∏ä‰º†ÂàóË°®
            const pmxUploadFile: UploadFile = {
                id: generateId(),
                name: zipContents.pmxFile.name,
                size: zipContents.pmxFile.size,
                file: zipContents.pmxFile,
                status: 'pending',
                progress: 0,
                uploadSpeed: 0
            }
            uploadFiles.value.push(pmxUploadFile)

            // Ê∑ªÂä†Á∫πÁêÜÊñá‰ª∂Âà∞‰∏ä‰º†ÂàóË°®
            for (const [fileName, textureFile] of zipContents.textures) {
                const textureUploadFile: UploadFile = {
                    id: generateId(),
                    name: fileName,
                    size: textureFile.size,
                    file: textureFile,
                    status: 'pending',
                    progress: 0,
                    uploadSpeed: 0
                }
                uploadFiles.value.push(textureUploadFile)
            }

            // Ê∑ªÂä† VMD Êñá‰ª∂Âà∞‰∏ä‰º†ÂàóË°®
            for (const vmdFile of zipContents.vmdFiles) {
                const vmdUploadFile: UploadFile = {
                    id: generateId(),
                    name: vmdFile.name,
                    size: vmdFile.size,
                    file: vmdFile,
                    status: 'pending',
                    progress: 0,
                    uploadSpeed: 0
                }
                uploadFiles.value.push(vmdUploadFile)
            }

            // Ëá™Âä®Â°´ÂÖÖÊ®°Âûã‰ø°ÊÅØ
            modelInfo.value.name = zipContents.pmxFile.name.replace(/\.[^/.]+$/, '')
            modelInfo.value.fileSize = uploadFiles.value.reduce((total, f) => total + f.size, 0)
            modelInfo.value.format = 'PMX'

            // Âä†ËΩΩÊ®°ÂûãÈ¢ÑËßàÔºà‰º†ÂÖ•ÂéüÂßã ZIP Êñá‰ª∂Áî®‰∫éÈ¢ÑËßàÔºâ
            loadModelPreview(file, 'zip')

            showSuccess(`ZIP Ëß£ÊûêÊàêÂäüÔºö${zipContents.pmxFile.name} + ${zipContents.textures.size} ‰∏™Á∫πÁêÜ + ${zipContents.vmdFiles.length} ‰∏™Âä®‰ΩúÊñá‰ª∂`)

            // Ëß¶Âèë‰∫ã‰ª∂
            emit('fileSelected', Array.from(uploadFiles.value.map(f => f.file)))

        } catch (error) {
            console.error('ZIP Êñá‰ª∂Ëß£ÊûêÂ§±Ë¥•:', error)
            showError('ZIP Êñá‰ª∂Ëß£ÊûêÂ§±Ë¥•: ' + (error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ'))
            return
        }
    } else {
        // Â§ÑÁêÜ GLB/GLTF Êñá‰ª∂
        const newFile: UploadFile = {
            id: generateId(),
            name: file.name,
            size: file.size,
            file,
            status: 'pending',
            progress: 0,
            uploadSpeed: 0
        }

        uploadFiles.value.push(newFile)

        // ËÆæÁΩÆÂΩìÂâçÊ®°ÂûãÁ±ªÂûã
        if (fileExtension === '.glb') {
            currentModelType.value = 'glb'
        } else if (fileExtension === '.gltf') {
            currentModelType.value = 'gltf'
        }

        // Ëá™Âä®Â°´ÂÖÖÊ®°Âûã‰ø°ÊÅØÂπ∂Âä†ËΩΩÈ¢ÑËßà
        modelInfo.value.name = file.name.replace(/\.[^/.]+$/, '')
        modelInfo.value.fileSize = file.size
        modelInfo.value.format = fileExtension.toUpperCase().slice(1)
        
        // Âä†ËΩΩÊ®°ÂûãÈ¢ÑËßà
        loadModelPreview(file, fileExtension.slice(1) as 'glb' | 'gltf')

        showSuccess(`${fileExtension.toUpperCase().slice(1)} Ê®°ÂûãÂä†ËΩΩÊàêÂäü`)

        // Ëß¶Âèë‰∫ã‰ª∂
        emit('fileSelected', [file])
    }
}

const validateFile = (file: File): boolean => {
    // Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞è
    const maxSize = props.maxFileSize * 1024 * 1024 * 5// MB to bytes
    if (file.size > maxSize) {
        showError(t('fileUploader.fileTooLarge', { name: file.name, size: props.maxFileSize }))
        return false
    }

    // Ê£ÄÊü•Êñá‰ª∂Á±ªÂûã
    const allowedExtensions = props.accept.split(',').map(ext => ext.trim().toLowerCase())
    const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase()

    if (!allowedExtensions.includes(fileExtension)) {
        showError(t('fileUploader.invalidFileType', { name: file.name }))
        return false
    }

    return true
}


// ÂàõÂª∫ÂèØÂèñÊ∂àÁöÑÂéãÁº©‰ªªÂä°
const createCancellableZip = async (
    zip: JSZip,
    signal: AbortSignal,
    onProgress: (progress: number) => void
): Promise<Blob> => {
    return new Promise((resolve, reject) => {
        // ÁõëÂê¨ÂèñÊ∂à‰ø°Âè∑
        const onAbort = () => {
            reject(new Error('ÂéãÁº©Ë¢´ÂèñÊ∂à'))
        }

        if (signal.aborted) {
            reject(new Error('ÂéãÁº©Ë¢´ÂèñÊ∂à'))
            return
        }

        signal.addEventListener('abort', onAbort)

        // ÁîüÊàêÂéãÁº©Êñá‰ª∂
        zip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: {
                level: 6
            }
        }, (metadata) => {
            // Ê£ÄÊü•ÊòØÂê¶Ë¢´ÂèñÊ∂à
            if (signal.aborted) {
                return
            }
            onProgress(metadata.percent)
        }).then((blob) => {
            signal.removeEventListener('abort', onAbort)
            if (signal.aborted) {
                reject(new Error('ÂéãÁº©Ë¢´ÂèñÊ∂à'))
            } else {
                resolve(blob)
            }
        }).catch((error) => {
            signal.removeEventListener('abort', onAbort)
            reject(error)
        })
    })
}


// ‰ΩøÁî®ÂéüÁîüXHR‰∏ä‰º†ZIPÊñá‰ª∂
const uploadWithXHR = async (zipBlob: Blob, files: UploadFile[], modelHash: string, modelScreenshot?: string): Promise<void> => {
    return new Promise(async (resolve, reject) => {
        try {
            const xhr = new XMLHttpRequest()
            const formData = new FormData()
            const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000/api'
            const zipFileName = `${modelHash}.zip` // ‰ΩøÁî®Ê®°ÂûãÊñá‰ª∂hash‰Ωú‰∏∫Êñá‰ª∂Âêç

            formData.append('file', zipBlob, zipFileName)

            // Ê∑ªÂä†Ê®°Âûã‰ø°ÊÅØÂà∞FormData
            const modelData = {
                name: modelInfo.value.name,
                description: modelInfo.value.description,
                size: modelInfo.value.fileSize.toString(),
                format: modelInfo.value.format,
                hash: modelHash,
                screenshot: modelScreenshot // Áõ¥Êé•Ê∑ªÂä†base64Êà™ÂõæÂ≠óÁ¨¶‰∏≤
            }
            formData.append('modelInfo', JSON.stringify(modelData))
            formData.append('user',JSON.stringify(authStore.user))
            // ÁõëÂê¨‰∏ä‰º†ËøõÂ∫¶
            xhr.upload.addEventListener('progress', (event) => {
                if (event.lengthComputable) {
                    const uploadProgress = (event.loaded / event.total) * 100
                    // ÂéãÁº©Âç†ÊÄ∞30%Ôºå‰∏ä‰º†Âç†ÊÄ∞70%
                    const totalProgress = 30 + (uploadProgress * 0.7)

                    files.forEach(file => {
                        file.progress = Math.round(totalProgress)

                        // ËÆ°ÁÆó‰∏ä‰º†ÈÄüÂ∫¶
                        if (file.startTime) {
                            const timeElapsed = (Date.now() - file.startTime) / 1000
                            file.uploadSpeed = event.loaded / timeElapsed
                        }

                        emit('uploadProgress', file)
                    })
                }
            })

            // ÁõëÂê¨‰∏ä‰º†ÂÆåÊàê
            xhr.addEventListener('load', () => {
                currentXHR.value = null // Ê∏ÖÈô§ÂºïÁî®
                if (xhr.status === 200) {
                    try {
                        const response = JSON.parse(xhr.responseText)
                        if (response.success) {
                            resolve()
                        } else {
                            reject(new Error(response.error || '‰∏ä‰º†Â§±Ë¥•'))
                        }
                    } catch (error) {
                        reject(new Error('ÊúçÂä°Âô®ÂìçÂ∫îÊ†ºÂºèÈîôËØØ'))
                    }
                } else if (xhr.status === 401) {
                    // ËÆ§ËØÅÂ§±Ë¥•
                    reject(new Error('ÁôªÂΩïÂ∑≤ËøáÊúüÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï'))
                } else if (xhr.status === 403) {
                    reject(new Error('TokenÊó†ÊïàÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï'))
                } else {
                    reject(new Error(`‰∏ä‰º†Â§±Ë¥•: ${xhr.status} ${xhr.statusText}`))
                }
            })

            // ÁõëÂê¨‰∏ä‰º†ÈîôËØØ
            xhr.addEventListener('error', () => {
                currentXHR.value = null // Ê∏ÖÈô§ÂºïÁî®
                reject(new Error('ÁΩëÁªúÈîôËØØ'))
            })

            // ÁõëÂê¨‰∏ä‰º†ÂèñÊ∂à
            xhr.addEventListener('abort', () => {
                currentXHR.value = null // Ê∏ÖÈô§ÂºïÁî®
                reject(new Error('‰∏ä‰º†Ë¢´ÂèñÊ∂à'))
            })

            // ÂºÄÂßã‰∏ä‰º†
            xhr.open('POST', API_BASE_URL + '/file/upload-zip')

            // Ê∑ªÂä†JWTËÆ§ËØÅÂ§¥
            if (authStore.token) {
                xhr.setRequestHeader('Authorization', `Bearer ${authStore.token}`)
            }

            xhr.send(formData)

            // ‰øùÂ≠òxhrÂºïÁî®‰ª•‰æøÂèñÊ∂à
            currentXHR.value = xhr
            files.forEach(file => {
                (file as any).xhr = xhr
            })
        } catch (error) {
            reject(new Error('ËÆ°ÁÆóhashÂ§±Ë¥•: ' + (error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')))
        }
    })
}

// Èò≤ÊäñÂèòÈáè
const isUploadingDebounce = ref(false)

const uploadAllFiles = async () => {
    // Èò≤ÊäñÊ£ÄÊü•
    if (isUploadingDebounce.value) {
        console.log('‚ö†Ô∏è ‰∏ä‰º†ÊåâÈíÆÈò≤Êäñ‰∏≠ÔºåÂøΩÁï•ÈáçÂ§çÁÇπÂáª')
        return
    }

    // ËÆæÁΩÆÈò≤ÊäñÊ†áÂøó
    isUploadingDebounce.value = true

    try {
    // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁôªÂΩï
    // if (!authStore.isAuthenticated) {
    //     showError('ËØ∑ÂÖàÁôªÂΩïÂêéÂÜç‰∏ä‰º†Êñá‰ª∂')
    //     return
    // }

    const filesToUpload = uploadFiles.value.filter(
        file => file.status === 'pending' || file.status === 'error'
    )

    if (filesToUpload.length === 0) {
        showWarning('Ê≤°ÊúâÂèØ‰∏ä‰º†ÁöÑÊñá‰ª∂')
        return
    }

    // ÁÆÄÂåñÁöÑÊñá‰ª∂Ê£ÄÊü•ÔºöZIP Êñá‰ª∂Âú®‰∏ä‰º†Êó∂È™åËØÅÂÜÖÂÆπÔºåGLB/GLTF Áõ¥Êé•‰∏ä‰º†

    const hasGlbFile = filesToUpload.some(file => {
        const ext = '.' + file.name.split('.').pop()?.toLowerCase()
        return ext === '.glb' || ext === '.gltf'
    })
    if (hasGlbFile) {
        if (!await checkGLBModel(filesToUpload[0].file)) {
            showError(`glbÊ®°ÂûãÂøÖÈ°ªÂåÖÂê´Âä®‰ΩúwalkÂíåstand}`)
            return
        }
    }

    try {
        // Âú®‰∏ä‰º†ÂâçÊà™Âõæ
        let modelScreenshot = ''
        if (hasModelLoaded.value) {
            modelScreenshot = captureModelScreenshot()
            console.log('Ê®°ÂûãÊà™ÂõæÂ∑≤ÁîüÊàêÔºåÈïøÂ∫¶:', modelScreenshot.length)
        }

        // ËÆæÁΩÆ‰∏ä‰º†Áä∂ÊÄÅ
        isUploading.value = true

        // Êõ¥Êñ∞ÊâÄÊúâÊñá‰ª∂Áä∂ÊÄÅ‰∏∫‰∏ä‰º†‰∏≠
        filesToUpload.forEach(file => {
            file.status = 'uploading'
            file.progress = 0
            file.startTime = Date.now()
        })
        // ÊâæÂà∞‰∏ªË¶ÅÊ®°ÂûãÊñá‰ª∂Ôºàglb/gltfÊàñpmxÔºâ
        const mainModelFile = filesToUpload.find(file => {
            const ext = '.' + file.name.split('.').pop()?.toLowerCase()
            return ext === '.glb' || ext === '.gltf' || ext === '.pmx'
        })

        if (!mainModelFile) {
            throw new Error('Êú™ÊâæÂà∞‰∏ªË¶ÅÊ®°ÂûãÊñá‰ª∂')
        }

        // ÂàõÂª∫ AbortController Áî®‰∫éÂèñÊ∂àÊìç‰Ωú
        abortController.value = new AbortController()
        const signal = abortController.value.signal

        // Ê£ÄÊü•ÊòØÂê¶Ë¢´ÂèñÊ∂à
        if (signal.aborted) {
            throw new Error('‰∏ä‰º†Ë¢´ÂèñÊ∂à')
        }

        // ËÆ°ÁÆó‰∏ªË¶ÅÊ®°ÂûãÊñá‰ª∂ÁöÑhash‰Ωú‰∏∫ÂéãÁº©ÂåÖÂêç
        console.log('Ê≠£Âú®ËÆ°ÁÆó‰∏ªË¶ÅÊ®°ÂûãÊñá‰ª∂hash:', mainModelFile.name)
        const modelHash = await calculateFileHash(mainModelFile.file, signal, currentWorkers.value)
        console.log('‰∏ªË¶ÅÊ®°ÂûãÊñá‰ª∂hash:', modelHash)

        // Ê£ÄÊü•ÊòØÂê¶Ë¢´ÂèñÊ∂à
        if (signal.aborted) {
            throw new Error('‰∏ä‰º†Ë¢´ÂèñÊ∂à')
        }

        // Áªü‰∏Ä‰∏ä‰º†ÈÄªËæëÔºöÊâÄÊúâÊñá‰ª∂ÈÉΩÂéãÁº©ÊàêZIP‰∏ä‰º†
        const zip = new JSZip()

        filesToUpload.forEach(uploadFile => {
            zip.file(uploadFile.name, uploadFile.file)
        })

        // ÁîüÊàêÂéãÁº©Êñá‰ª∂ÔºàÊîØÊåÅÂèñÊ∂àÔºâ
        const zipBlob = await createCancellableZip(zip, signal, (progress) => {
            // Êõ¥Êñ∞ÂéãÁº©ËøõÂ∫¶
            filesToUpload.forEach(file => {
                file.progress = Math.round(progress * 0.3) // ÂéãÁº©Âç†30%ËøõÂ∫¶
                emit('uploadProgress', file)
            })
        })

        // ‰ΩøÁî®ÂéüÁîüXHR‰∏ä‰º†
        await uploadWithXHR(zipBlob, filesToUpload, modelHash, modelScreenshot)

        // ÊâÄÊúâÊñá‰ª∂‰∏ä‰º†ÂÆåÊàê
        filesToUpload.forEach(file => {
            file.status = 'completed'
            file.progress = 100
            emit('uploadCompleted', file)
        })

        showSuccess('Êñá‰ª∂‰∏ä‰º†ÂÆåÊàê')
        emit('allUploadsCompleted', filesToUpload)

    } catch (error) {
        // ÊâÄÊúâÊñá‰ª∂‰∏ä‰º†Â§±Ë¥•
        filesToUpload.forEach(file => {
            file.status = 'error'
            file.errorMessage = error instanceof Error ? error.message : t('fileUploader.uploadFailed')
            emit('uploadError', file, file.errorMessage)
        })
        showError('Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•')
    } finally {
        // ÈáçÁΩÆ‰∏ä‰º†Áä∂ÊÄÅ
        isUploading.value = false
        currentXHR.value = null // Ê∏ÖÈô§xhrÂºïÁî®
        abortController.value = null // Ê∏ÖÈô§AbortControllerÂºïÁî®
        // Ê∏ÖÁêÜÊâÄÊúâworkers
        currentWorkers.value.forEach(worker => {
            worker.terminate()
        })
        currentWorkers.value = []

        // Ê∏ÖÈô§Èò≤ÊäñÊ†áÂøóÔºàÂª∂Ëøü500msÈò≤Ê≠¢Âø´ÈÄüÈáçÂ§çÁÇπÂáªÔºâ
        setTimeout(() => {
            isUploadingDebounce.value = false
        }, 500)
    }
    } catch (outerError) {
        console.error('‰∏ä‰º†ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:', outerError)
        showError('‰∏ä‰º†Â§±Ë¥•: ' + (outerError instanceof Error ? outerError.message : 'Êú™Áü•ÈîôËØØ'))

        // Ê∏ÖÈô§Èò≤ÊäñÊ†áÂøó
        setTimeout(() => {
            isUploadingDebounce.value = false
        }, 500)
    }
}


const clearCompletedFiles = () => {
    uploadFiles.value = uploadFiles.value.filter(file => file.status !== 'completed')
}

const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes'

    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

const formatSpeed = (bytesPerSecond: number): string => {
    if (bytesPerSecond === 0) return '0 B/s'

    const k = 1024
    const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s']
    const i = Math.floor(Math.log(bytesPerSecond) / Math.log(k))

    return parseFloat((bytesPerSecond / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}

const generateId = (): string => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2)
}


// Three.js ÂàùÂßãÂåñ
const initThreeJS = () => {
    if (!modelCanvas.value) {
        console.error('‚ùå Ê®°ÂûãÁîªÂ∏ÉÊú™ÊâæÂà∞ÔºåÊó†Ê≥ïÂàùÂßãÂåñThree.js')
        return
    }

    try {
        console.log('üîß ÂºÄÂßãÂàùÂßãÂåñThree.js...')

        // Ê∏ÖÁêÜ‰πãÂâçÁöÑËµÑÊ∫ê
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId)
            animationFrameId = null
        }

        if (renderer) {
            renderer.dispose()
        }

        if (controls) {
            controls.dispose()
        }

        // Âú∫ÊôØ
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0x1a1a1a)
        console.log('‚úÖ Âú∫ÊôØÂàõÂª∫ÂÆåÊàê')

        // Áõ∏Êú∫
        camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000)
        camera.position.set(0, 1, 3)
        console.log('‚úÖ Áõ∏Êú∫ÂàõÂª∫ÂÆåÊàê')

        // Ê∏≤ÊüìÂô®
        renderer = new THREE.WebGLRenderer({
            canvas: modelCanvas.value,
            antialias: true,
            preserveDrawingBuffer: true // ‰øùÊåÅÁªòÂà∂ÁºìÂÜ≤Âå∫ÔºåÁî®‰∫éÊà™Âõæ
        })
        renderer.setSize(300, 300)
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap
        console.log('‚úÖ Ê∏≤ÊüìÂô®ÂàõÂª∫ÂÆåÊàê')

        // ÊéßÂà∂Âô®
        controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.1
        controls.enableZoom = true
        console.log('‚úÖ ÊéßÂà∂Âô®ÂàõÂª∫ÂÆåÊàê')

        // ÁÅØÂÖâ
        const ambientLight = new THREE.AmbientLight(0xffffff, 1)
        scene.add(ambientLight)

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
        directionalLight.position.set(1, 1, 1)
        directionalLight.castShadow = true
        scene.add(directionalLight)
        console.log('‚úÖ ÁÅØÂÖâÊ∑ªÂä†ÂÆåÊàê')

        // ÂºÄÂßãÊ∏≤ÊüìÂæ™ÁéØ
        animate()
        console.log('üéâ Three.jsÂàùÂßãÂåñÂÆåÊàê')
    } catch (error) {
        console.error('‚ùå Three.jsÂàùÂßãÂåñÂ§±Ë¥•:', error)
        showError('3DÈ¢ÑËßàÂàùÂßãÂåñÂ§±Ë¥•')
    }
}

// Âä®ÁîªÂæ™ÁéØ
const animate = () => {
    if (!renderer || !scene || !camera || !controls) {
        console.warn('‚ö†Ô∏è Âä®ÁîªÂæ™ÁéØÂÅúÊ≠¢ÔºöThree.jsÁªÑ‰ª∂Êú™Â∞±Áª™')
        return
    }

    try {
        animationFrameId = requestAnimationFrame(animate)
        controls.update()
        renderer.render(scene, camera)
    } catch (error) {
        console.error('‚ùå Ê∏≤ÊüìÈîôËØØ:', error)
        // Â∞ùËØïÈáçÊñ∞ÂàùÂßãÂåñ
        ensureThreeJSReady()
    }
}

// ZIP Êñá‰ª∂ÂÜÖÂÆπÊé•Âè£
interface ZipContents {
    pmxFile?: File
    textures: Map<string, File>
    vmdFiles: File[]
}

// Ëß£Êûê ZIP Êñá‰ª∂ÂÜÖÂÆπ
const parseZipFile = async (zipFile: File): Promise<ZipContents> => {
    const zip = new JSZip()
    const zipContent = await zip.loadAsync(zipFile)
    
    const contents: ZipContents = {
        textures: new Map(),
        vmdFiles: []
    }
    
    for (const [fileName, fileEntry] of Object.entries(zipContent.files)) {
        if (fileEntry.dir) continue
        
        const ext = '.' + fileName.split('.').pop()?.toLowerCase()
        
        if (ext === '.pmx') {
            const blob = await fileEntry.async('blob')
            contents.pmxFile = new File([blob], fileName)
        } else if (ext === '.png' || ext === '.jpg' || ext === '.jpeg') {
            const blob = await fileEntry.async('blob')
            const textureFile = new File([blob], fileName)
            contents.textures.set(fileName, textureFile)
        } else if (ext === '.vmd') {
            const blob = await fileEntry.async('blob')
            const vmdFile = new File([blob], fileName)
            contents.vmdFiles.push(vmdFile)
        }
    }
    
    return contents
}

// Âä†ËΩΩÊ®°ÂûãÈ¢ÑËßà
const loadModelPreview = async (file: File, fileType: 'glb' | 'gltf' | 'zip') => {
    console.log('üéØ ÂºÄÂßãÂä†ËΩΩÊ®°ÂûãÈ¢ÑËßà:', fileType)

    // Á°Æ‰øùThree.jsÂú∫ÊôØÂáÜÂ§áÂ∞±Áª™
    ensureThreeJSReady()

    // Á≠âÂæÖ‰∏ã‰∏ÄÂ∏ßÁ°Æ‰øùDOMÊõ¥Êñ∞
    await nextTick()

    if (!scene || !renderer || !camera || !controls) {
        console.error('‚ùå Three.jsÂú∫ÊôØÊú™Ê≠£Á°ÆÂàùÂßãÂåñ')
        showError('3DÈ¢ÑËßàÂàùÂßãÂåñÂ§±Ë¥•')
        return
    }

    console.log('‚úÖ Three.jsÂú∫ÊôØÊ£ÄÊü•ÈÄöËøá')

    // Ê∏ÖÈô§‰πãÂâçÁöÑÊ®°Âûã
    if (currentModel) {
        scene.remove(currentModel)
        disposeModel(currentModel)
        currentModel = null
    }

    try {
        if (fileType === 'glb' || fileType === 'gltf') {
            const loader = new GLTFLoader()
            const fileURL = createManagedURL(file)

            loader.load(fileURL, (gltf) => {
                currentModel = gltf.scene
                scene!.add(currentModel)
                
                const box = new THREE.Box3().setFromObject(currentModel)
                const center = box.getCenter(new THREE.Vector3())
                const size = box.getSize(new THREE.Vector3())
                
                currentModel.position.sub(center)
                
                const maxDim = Math.max(size.x, size.y, size.z)
                camera!.position.set(0, maxDim * 0.5, maxDim * 2)
                controls!.target.set(0, 0, 0)
                controls!.update()
                
                hasModelLoaded.value = true

                showSuccess('Ê®°ÂûãÂä†ËΩΩÊàêÂäü')
            }, undefined, (error) => {
                console.error('Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•:', error)
                showError('Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•')
            })
        } else if (fileType === 'zip') {
            try {
                showSuccess('Ê≠£Âú®Ëß£Êûê ZIP Êñá‰ª∂...')
                const zipContents = await parseZipFile(file)
                
                if (!zipContents.pmxFile) {
                    showError('ZIP Êñá‰ª∂‰∏≠Êú™ÊâæÂà∞ PMX Ê®°ÂûãÊñá‰ª∂')
                    return
                }
                
                // Êõ¥Êñ∞Ê®°Âûã‰ø°ÊÅØ
                currentModelType.value = 'pmx'
                modelInfo.value.format = 'PMX'
                
                const textureURLs: string[] = []
                const textureURLMap = new Map<string, string>()

                for (const [fileName, textureFile] of zipContents.textures) {
                    const textureURL = createManagedURL(textureFile)
                    textureURLs.push(textureURL)
                    textureURLMap.set(fileName, textureURL)
                    console.log(`üìù ÁîüÊàêÁ∫πÁêÜURL: ${fileName} -> ${textureURL}`)
                }

                // ÂàõÂª∫Ëá™ÂÆö‰πâÁöÑLoadingManagerÊù•ÈáçÂÆöÂêëÁ∫πÁêÜÊñá‰ª∂URL
                const tempLoadingManager = new THREE.LoadingManager()

                // ÁõëÂê¨ÊâÄÊúâËµÑÊ∫êÂä†ËΩΩÂÆåÊàê
                tempLoadingManager.onLoad = () => {
                    console.log('üéâ ÊâÄÊúâËµÑÊ∫êÔºàÂåÖÊã¨Á∫πÁêÜÔºâÂä†ËΩΩÂÆåÊàê')
                    // URL‰ºöÂú®ÁªÑ‰ª∂Âç∏ËΩΩÊó∂Áªü‰∏ÄÊ∏ÖÁêÜÔºåËøôÈáå‰∏çÈúÄË¶ÅÊâãÂä®Ê∏ÖÁêÜ
                }

                tempLoadingManager.resolveURL = function(url: string) {
                    // ÊèêÂèñÊñá‰ª∂Âêç
                    const fileName = url.split('/').pop() || url
                    // Â¶ÇÊûúÂú®Êàë‰ª¨ÁöÑÁ∫πÁêÜÊò†Â∞Ñ‰∏≠ÊâæÂà∞‰∫ÜÂØπÂ∫îÁöÑURLÔºåÂ∞±‰ΩøÁî®ÂÆÉ
                    if (textureURLMap.has(fileName)) {
                        console.log(`üîó ÈáçÂÆöÂêëÁ∫πÁêÜURL: ${fileName} -> ${textureURLMap.get(fileName)}`)
                        return textureURLMap.get(fileName)!
                    }
                    return url
                }
                
                // Âä†ËΩΩ PMX Ê®°ÂûãÔºå‰ΩøÁî®Ëá™ÂÆö‰πâÁöÑLoadingManagerÊù•Â§ÑÁêÜÁ∫πÁêÜURLÈáçÂÆöÂêë
                const loader = new MMDLoader(tempLoadingManager)
                const pmxURL = createManagedURL(zipContents.pmxFile)

                loader.load(pmxURL, (mmd) => {
                    currentModel = new THREE.Group()

                    if (mmd instanceof THREE.SkinnedMesh) {
                        // PMXÂä†ËΩΩÂô®‰ºöËá™Âä®Â§ÑÁêÜÁ∫πÁêÜÔºåÊàë‰ª¨Âè™ÈúÄË¶ÅÊ∑ªÂä†Ê®°ÂûãÂà∞Âú∫ÊôØ
                        currentModel.add(mmd)
                        console.log(`‚úÖ PMXÊ®°ÂûãÂä†ËΩΩÊàêÂäüÔºåÂåÖÂê´ ${zipContents.textures.size} ‰∏™Á∫πÁêÜÊñá‰ª∂`)
                    } else if (mmd && typeof mmd === 'object' && 'isObject3D' in mmd) {
                        // Â¶ÇÊûúÊòØÂÖ∂‰ªñÁ±ªÂûãÁöÑObject3D
                        currentModel.add(mmd as THREE.Object3D)
                        console.log(`‚úÖ PMXÊ®°Âûã‰Ωú‰∏∫Object3DÂä†ËΩΩÊàêÂäü`)
                    } else {
                        showError('PMXÊ®°ÂûãÊ†ºÂºè‰∏çÂÖºÂÆπ')
                    }
                    
                    scene!.add(currentModel)

                    const box = new THREE.Box3().setFromObject(currentModel)
                    const center = box.getCenter(new THREE.Vector3())
                    const size = box.getSize(new THREE.Vector3())
                    
                    currentModel.position.sub(center)
                    
                    const maxDim = Math.max(size.x, size.y, size.z)
                    camera!.position.set(0, maxDim * 0.5, maxDim * 2)
                    controls!.target.set(0, 0, 0)
                    controls!.update()

                    hasModelLoaded.value = true

                    showSuccess(`PMXÊ®°ÂûãÂä†ËΩΩÊàêÂäü (ÂåÖÂê´ ${zipContents.textures.size} ‰∏™Á∫πÁêÜ, ${zipContents.vmdFiles.length} ‰∏™Âä®‰ΩúÊñá‰ª∂)`)
                }, undefined, (error: any) => {
                    console.error('PMXÊ®°ÂûãÂä†ËΩΩÂ§±Ë¥•:', error)
                    showError('PMXÊ®°ÂûãÂä†ËΩΩÂ§±Ë¥•: ' + (error?.message || 'Êú™Áü•ÈîôËØØ'))

                    hasModelLoaded.value = true
                })
                
            } catch (error) {
                console.error('ZIP Êñá‰ª∂Ëß£ÊûêÂ§±Ë¥•:', error)
                showError('ZIP Êñá‰ª∂Ëß£ÊûêÂ§±Ë¥•: ' + (error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ'))
            }
        }
    } catch (error) {
        console.error('Ê®°ÂûãÈ¢ÑËßàÂ§±Ë¥•:', error)
        showError('Ê®°ÂûãÈ¢ÑËßàÂ§±Ë¥•')
    }
}

// URLÂØπË±°ÁÆ°ÁêÜ
const createManagedURL = (blob: Blob): string => {
    const url = URL.createObjectURL(blob)
    activeURLs.value.push(url)
    return url
}

const cleanupAllURLs = () => {
    activeURLs.value.forEach(url => {
        URL.revokeObjectURL(url)
    })
    activeURLs.value = []
    console.log('üßπ Â∑≤Ê∏ÖÁêÜÊâÄÊúâURLÂØπË±°')
}

// Ê∑±Â∫¶Ê∏ÖÁêÜThree.jsÊ®°ÂûãËµÑÊ∫ê
const disposeModel = (model: THREE.Object3D) => {
    model.traverse((child) => {
        if (child instanceof THREE.Mesh) {
            // Ê∏ÖÁêÜÂá†‰Ωï‰Ωì
            if (child.geometry) {
                child.geometry.dispose()
            }

            // Ê∏ÖÁêÜÊùêË¥®ÂíåÁ∫πÁêÜ
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => {
                        disposeMaterial(material)
                    })
                } else {
                    disposeMaterial(child.material)
                }
            }
        }
    })
}

// Ê∏ÖÁêÜÊùêË¥®ÂíåÁõ∏ÂÖ≥Á∫πÁêÜ
const disposeMaterial = (material: THREE.Material) => {
    // Ê∏ÖÁêÜÊâÄÊúâÂèØËÉΩÁöÑÁ∫πÁêÜ
    const textureProperties = [
        'map', 'normalMap', 'roughnessMap', 'metalnessMap',
        'aoMap', 'emissiveMap', 'bumpMap', 'displacementMap',
        'alphaMap', 'lightMap', 'envMap'
    ]

    textureProperties.forEach(prop => {
        if ((material as any)[prop]) {
            (material as any)[prop].dispose()
        }
    })

    material.dispose()
}

// ÊâßË°åÂÆåÊï¥ÁöÑËµÑÊ∫êÊ∏ÖÁêÜÔºàÂºπÁ™óÂÖ≥Èó≠Êó∂Ë∞ÉÁî®Ôºâ
const performResourceCleanup = () => {
    console.log('üßπ ÂºÄÂßãÊâßË°åËµÑÊ∫êÊ∏ÖÁêÜ...')

    // 1. ÂèñÊ∂àÊâÄÊúâÊ≠£Âú®ËøõË°åÁöÑÊìç‰Ωú
    if (abortController.value) {
        abortController.value.abort()
        abortController.value = null
    }

    // 2. ÁªàÊ≠¢ÊâÄÊúâWeb Workers
    currentWorkers.value.forEach(worker => {
        worker.terminate()
    })
    currentWorkers.value = []

    // 3. ÂèñÊ∂àXHRËØ∑Ê±Ç
    if (currentXHR.value) {
        currentXHR.value.abort()
        currentXHR.value = null
    }

    // 4. Ê∏ÖÁêÜÂä®ÁîªÂæ™ÁéØ
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId)
        animationFrameId = null
    }

    // 5. Ê∏ÖÁêÜThree.jsËµÑÊ∫ê
    if (currentModel) {
        disposeModel(currentModel)
        currentModel = null
    }

    // 6. Ê∏ÖÁêÜÂú∫ÊôØ
    if (scene) {
        scene.traverse((child) => {
            if (child instanceof THREE.Object3D) {
                disposeModel(child)
            }
        })
        scene.clear()
    }

    // 7. Ê∏ÖÁêÜÊâÄÊúâURLÂØπË±°
    cleanupAllURLs()

    console.log('‚úÖ ËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê')
}

// Êà™ÂõæÂäüËÉΩ
const captureModelScreenshot = (): string => {
    if (!renderer || !modelCanvas.value) {
        return ''
    }
    
    // Ê∏≤Êüì‰∏ÄÂ∏ß‰ª•Á°Æ‰øùÊúÄÊñ∞Áä∂ÊÄÅ
    renderer.render(scene!, camera!)
    
    // Ëé∑Âèñ canvas ÁöÑ base64 Êï∞ÊçÆ
    return modelCanvas.value.toDataURL('image/png')
}

// ÈáçÁΩÆÊ®°ÂûãËßÜËßí
const resetModelView = () => {
    if (!camera || !controls || !currentModel) return

    const box = new THREE.Box3().setFromObject(currentModel)
    const size = box.getSize(new THREE.Vector3())
    const maxDim = Math.max(size.x, size.y, size.z)
    
    camera.position.set(0, maxDim * 0.5, maxDim * 2)
    controls.target.set(0, 0, 0)
    controls.update()
}

// ÈáçÁΩÆ‰∏ä‰º†Áä∂ÊÄÅ
const resetUploadState = () => {
    uploadFiles.value = []
    currentModelType.value = null
    waitingForVmd.value = false
    isDetectingAnimation.value = false
    isUploading.value = false
    isUploadingDebounce.value = false // Ê∏ÖÁêÜÈò≤ÊäñÁä∂ÊÄÅ

    // ÈáçÁΩÆ‰ø°ÊÅØË°®Âçï
    modelInfo.value = {
        name: '',
        description: '',
        fileSize: 0,
        format: ''
    }

    // ÈáçÁΩÆÊ®°ÂûãÈ¢ÑËßà
    hasModelLoaded.value = false
    if (currentModel && scene) {
        scene.remove(currentModel)
        disposeModel(currentModel)
        currentModel = null
    }

    // Á°Æ‰øùThree.jsÂú∫ÊôØÊ≠£Â∏∏Â∑•‰Ωú
    ensureThreeJSReady()
}

// Á°Æ‰øùThree.jsÂú∫ÊôØÂáÜÂ§áÂ∞±Áª™
const ensureThreeJSReady = () => {
    if (!modelCanvas.value) return

    // Ê£ÄÊü•Ê∏≤ÊüìÂô®ÊòØÂê¶ËøòÊúâÊïà
    if (!renderer || renderer.domElement !== modelCanvas.value) {
        console.log('üîÑ ÈáçÊñ∞ÂàùÂßãÂåñThree.jsÊ∏≤ÊüìÂô®')
        initThreeJS()
        return
    }

    // Ê£ÄÊü•Âú∫ÊôØÊòØÂê¶Â≠òÂú®
    if (!scene) {
        console.log('üîÑ ÈáçÊñ∞ÂàõÂª∫Three.jsÂú∫ÊôØ')
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0x1a1a1a)

        // ÈáçÊñ∞Ê∑ªÂä†ÁÅØÂÖâ
        const ambientLight = new THREE.AmbientLight(0xffffff, 1)
        scene.add(ambientLight)

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
        directionalLight.position.set(1, 1, 1)
        directionalLight.castShadow = true
        scene.add(directionalLight)
    }

    // Á°Æ‰øùÂä®ÁîªÂæ™ÁéØÊ≠£Âú®ËøêË°å
    if (!animationFrameId) {
        console.log('üîÑ ÈáçÊñ∞ÂêØÂä®Âä®ÁîªÂæ™ÁéØ')
        animate()
    }
}

// ÂèñÊ∂à‰∏ä‰º†
const cancelUpload = () => {
    // Ê£ÄÊü•ÊòØÂê¶ÊúâÊ≠£Âú®ËøõË°åÁöÑÊìç‰Ωú
    if (!isUploading.value) {
        showWarning('Ê≤°ÊúâÊ≠£Âú®ËøõË°åÁöÑÊìç‰Ωú')
        return
    }

    const uploadingFiles = uploadFiles.value.filter(file => file.status === 'uploading')

    if (uploadingFiles.length > 0) {
        // 1. ÂèñÊ∂à AbortControllerÔºàËøô‰ºöÂÅúÊ≠¢hashËÆ°ÁÆóÂíåÂéãÁº©Ôºâ
        if (abortController.value) {
            abortController.value.abort()
            abortController.value = null
        }

        // 2. ÁªàÊ≠¢ÊâÄÊúâ Workers
        currentWorkers.value.forEach(worker => {
            worker.terminate()
        })
        currentWorkers.value = []

        // 3. ÂèñÊ∂àXHRËØ∑Ê±Ç
        if (currentXHR.value) {
            currentXHR.value.abort()
            currentXHR.value = null
        }

        // 4. ÈáçÁΩÆÊñá‰ª∂Áä∂ÊÄÅ
        uploadingFiles.forEach(file => {
            file.status = 'pending'
            file.progress = 0
            file.uploadSpeed = 0
            file.errorMessage = undefined
            // Ê∏ÖÈô§Êñá‰ª∂‰∏äÁöÑxhrÂºïÁî®
            delete (file as any).xhr
        })

        // 5. ÈáçÁΩÆ‰∏ä‰º†Áä∂ÊÄÅ
        isUploading.value = false
        showInfo('Â∑≤ÂèñÊ∂à‰∏ä‰º†')
    } else {
        showWarning('Ê≤°ÊúâÊ≠£Âú®‰∏ä‰º†ÁöÑÊñá‰ª∂')
    }
}

// ‰øÆÊîπÂÖ≥Èó≠ÂØπËØùÊ°ÜÊñπÊ≥ï
const closeUploadDialog = () => {
    console.log('üö™ ÂÖ≥Èó≠‰∏ä‰º†ÂºπÁ™óÔºåÂºÄÂßãÊ∏ÖÁêÜËµÑÊ∫ê...')

    // 1. Âº∫Âà∂ÂèñÊ∂àÊâÄÊúâÊ≠£Âú®ËøõË°åÁöÑ‰∏ä‰º†
    if (isUploading.value) {
        cancelUpload()
        console.log('üõë Â∑≤ÂèñÊ∂àÊ≠£Âú®ËøõË°åÁöÑ‰∏ä‰º†')
    }

    // 2. ÊâßË°åÂÆåÊï¥ÁöÑËµÑÊ∫êÊ∏ÖÁêÜ
    performResourceCleanup()

    // 3. ÈáçÁΩÆÊâÄÊúâÁä∂ÊÄÅ
    resetUploadState()

    // 4. ÂÖ≥Èó≠ÂºπÁ™ó
    showUpload.value = false

    console.log('‚úÖ ‰∏ä‰º†ÂºπÁ™óÂÖ≥Èó≠ÔºåËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê')
}

const checkGLBModel = async (file: File) => {
    const glbLoader = new GLTFLoader()
    const fileArrayBuffer = await file.arrayBuffer()
    return new Promise((resolve) => {
        glbLoader.parse(fileArrayBuffer, '', (gltf) => {
            let n = 0;
            gltf.animations.forEach((animation) => {
                if (animation.name === 'walk') n++
                if (animation.name === 'stand') n++
            })
            if (n === 2) {
                return resolve(true)
            } else {
                return resolve(false)
            }
        }, () => resolve(false))
    })

}

// ÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜ
onMounted(() => {
    console.log('üöÄ FileUploaderÁªÑ‰ª∂Â∑≤ÊåÇËΩΩ')
    // Âú®ÁªÑ‰ª∂ÊåÇËΩΩÂêéÂàùÂßãÂåñ Three.js
    nextTick(() => {
        if (modelCanvas.value) {
            console.log('üéØ ÂàùÂßãÂåñThree.jsÂú∫ÊôØ')
            initThreeJS()
        } else {
            console.warn('‚ö†Ô∏è Ê®°ÂûãÁîªÂ∏ÉÊú™ÊâæÂà∞')
        }
    })
})

onUnmounted(() => {
    console.log('üßπ ÁªÑ‰ª∂Âç∏ËΩΩÔºåÊâßË°åÊúÄÁªàËµÑÊ∫êÊ∏ÖÁêÜ...')

    // ÊâßË°åÂÆåÊï¥ÁöÑËµÑÊ∫êÊ∏ÖÁêÜ
    performResourceCleanup()

    // È¢ùÂ§ñÊ∏ÖÁêÜÊ∏≤ÊüìÂô®ÂíåÊéßÂà∂Âô®ÂºïÁî®
    if (controls) {
        controls.dispose()
        controls = null
    }

    if (renderer) {
        renderer.dispose()
        renderer.forceContextLoss()
        renderer = null
    }

    // Ê∏ÖÁêÜÂú∫ÊôØÂíåÁõ∏Êú∫ÂºïÁî®
    scene = null
    camera = null

    console.log('‚úÖ ÁªÑ‰ª∂Âç∏ËΩΩÊ∏ÖÁêÜÂÆåÊàê')
})


// Êö¥Èú≤ÊñπÊ≥ïÁªôÁà∂ÁªÑ‰ª∂
defineExpose({
    triggerFileSelect,
    uploadAllFiles,
    clearCompletedFiles,
    resetUploadState,
    getUploadFiles: () => uploadFiles.value
})
</script>

<style scoped>
/* ‰∏ä‰º†ÊåâÈíÆÊ†∑Âºè */
.upload-button {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 15px 25px;
    background: linear-gradient(45deg, #ff00ff, #00ffff);
    border: none;
    border-radius: 12px;
    color: #000000;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.upload-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(255, 0, 255, 0.4);
}

.upload-icon {
    font-size: 1.2rem;
}

/* ‰∏ä‰º†ÂØπËØùÊ°ÜÊ†∑Âºè */
.upload-dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.upload-dialog {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    border: 1px solid rgba(0, 255, 255, 0.3);
    backdrop-filter: blur(20px);
    width: 90%;
    height: 85%;
    max-width: none;
    max-height: none;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.upload-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 30px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.upload-header h3 {
    color: #00ffff;
    font-size: 1.3rem;
    margin: 0;
}

.close-btn {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.close-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    color: #ffffff;
}

.upload-content-wrapper {
    flex: 1;
    display: flex;
    flex-direction: row;
    min-height: 0;
    overflow: hidden;
}

.upload-section {
    flex: 1;
    min-width: 0;
    padding: 30px;
    border-right: 1px solid rgba(255, 255, 255, 0.1);
    overflow-y: auto;
}

.upload-content {
    display: flex;
    flex-direction: column;
    min-height: 0;
    position: relative;
}

.info-section {
    flex: 1;
    min-width: 0;
    padding: 30px;
    overflow-y: auto;
}

.info-form {
    max-width: 100%;
}

.form-title {
    color: #00ffff;
    font-size: 1.2rem;
    margin: 0 0 20px 0;
    font-weight: 600;
}

.form-group {
    margin-bottom: 20px;
}

.form-label {
    display: block;
    color: #ffffff;
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 8px;
}

.required {
    color: #ef4444;
    font-size: 0.8rem;
}

/* Ê®°ÂûãÈ¢ÑËßàÂå∫Âüü */
.model-preview-area {
    border: 2px dashed rgba(0, 255, 255, 0.5);
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.05);
    transition: all 0.3s ease;
    position: relative;
    min-height: 300px;
    overflow: hidden;
}

.model-preview-area.has-model {
    border-style: solid;
    border-color: rgba(0, 255, 255, 0.7);
    background: rgba(0, 0, 0, 0.3);
}

.model-preview-container {
    position: relative;
    width: 100%;
    height: 300px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.model-canvas {
    width: 100%;
    height: 100%;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.8);
}

.model-overlay {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
}

.model-controls {
    display: flex;
    gap: 8px;
}

.control-btn {
    background: rgba(0, 0, 0, 0.7);
    border: 1px solid rgba(0, 255, 255, 0.5);
    color: #00ffff;
    padding: 8px;
    border-radius: 6px;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
}

.control-btn:hover {
    background: rgba(0, 255, 255, 0.2);
    border-color: #00ffff;
    color: #ffffff;
    transform: scale(1.1);
}

.model-upload-prompt {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 50px 20px;
    text-align: center;
    color: rgba(255, 255, 255, 0.6);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.model-upload-prompt .upload-icon {
    font-size: 3rem;
    margin-bottom: 15px;
    display: block;
    color: rgba(0, 255, 255, 0.5);
}

.model-upload-prompt p {
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 8px;
}

.model-upload-prompt .upload-note {
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.9rem;
    margin-bottom: 0;
}

/* Ë°®ÂçïËæìÂÖ• */
.form-input,
.form-textarea {
    width: 100%;
    padding: 12px 15px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: #ffffff;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    box-sizing: border-box;
}

.form-input:focus,
.form-textarea:focus {
    outline: none;
    border-color: #00ffff;
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 0 0 2px rgba(0, 255, 255, 0.2);
}

.form-input::placeholder,
.form-textarea::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

.form-textarea {
    resize: vertical;
    min-height: 80px;
}

.input-hint {
    margin-top: 5px;
    font-size: 0.8rem;
    color: rgba(0, 255, 255, 0.8);
    text-align: right;
}

/* Â§ßÂ∞èÊòæÁ§∫ */
.size-display {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 15px;
}

.size-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.size-item:last-child {
    margin-bottom: 0;
}

.size-item span:first-child {
    color: rgba(255, 255, 255, 0.8);
    font-size: 0.9rem;
}

.size-item span:last-child {
    color: #00ffff;
    font-weight: 600;
}


/* Âä®‰ΩúÊ£ÄÊµãËíôÁâàÊ†∑Âºè */
.detection-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    border-radius: 12px;
}

.detection-content {
    text-align: center;
    color: #fff;
}

.loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(0, 255, 255, 0.3);
    border-top: 4px solid #00ffff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 15px;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }

    100% {
        transform: rotate(360deg);
    }
}

/* ÊãñÊãΩ‰∏ä‰º†Âå∫ÂüüÊ†∑Âºè */
.drag-upload-area {
    border: 2px dashed rgba(0, 255, 255, 0.5);
    border-radius: 12px;
    padding: 20px 20px;
    text-align: center;
    background: rgba(255, 255, 255, 0.05);
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 20px;
}

.drag-upload-area:hover,
.drag-upload-area.drag-over {
    border-color: #00ffff;
    background: rgba(0, 255, 255, 0.1);
}

.drag-upload-area.waiting-vmd {
    border-color: #ff00ff;
    background: rgba(255, 0, 255, 0.1);
}

.drag-upload-area.uploading {
    border-color: #fbbf24;
    background: rgba(251, 191, 36, 0.1);
    cursor: not-allowed;
    pointer-events: none;
    opacity: 0.7;
}

.drag-upload-area.uploading .select-file-btn {
    background: rgba(107, 114, 128, 0.5);
    color: rgba(255, 255, 255, 0.5);
    cursor: not-allowed;
    pointer-events: none;
}

.uploading-prompt {
    color: #fbbf24 !important;
    font-weight: 600;
}

.missing-files-prompt {
    color: #ef4444 !important;
    font-weight: 600;
    font-size: 0.85rem;
    margin-top: 5px;
}

.vmd-prompt {
    color: #ff00ff !important;
    font-weight: 600;
}

.drag-upload-area .upload-icon {
    font-size: 3rem;
    margin-bottom: 15px;
    display: block;
}

.drag-upload-area p {
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 10px;
}

.upload-note {
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.9rem;
    margin-bottom: 8px;
}

.format-requirements {
    color: rgba(0, 255, 255, 0.8);
    font-size: 0.8rem;
    margin-bottom: 15px;
    line-height: 1.4;
    max-width: 300px;
    margin-left: auto;
    margin-right: auto;
}

.select-file-btn {
    background: rgba(0, 255, 255, 0.2);
    border: 1px solid #00ffff;
    color: #00ffff;
    padding: 12px 25px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
}

.select-file-btn:hover {
    background: rgba(0, 255, 255, 0.3);
    transform: translateY(-2px);
}

/* ‰∏ä‰º†ÂàóË°®Ê†∑Âºè */
.upload-list {
    margin-top: 20px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    backdrop-filter: blur(10px);
    flex: 1;
    min-height: 0;
    overflow-y: auto;
}

.upload-list::-webkit-scrollbar {
    width: 8px;
}

.upload-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}

.upload-list::-webkit-scrollbar-thumb {
    background: rgba(0, 255, 255, 0.5);
    border-radius: 4px;
}

.upload-list::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 255, 255, 0.7);
}

.list-title {
    margin: 0 0 16px 0;
    color: #fff;
    font-size: 16px;
    font-weight: 600;
}

.file-items {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.file-item {
    padding: 16px;
    background: rgba(255, 255, 255, 0.08);
    border-radius: 8px;
    border-left: 4px solid #3b82f6;
    transition: all 0.3s ease;
}

.file-item.completed {
    border-left-color: #10b981;
}

.file-item.error {
    border-left-color: #ef4444;
}

.file-info {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
}

/* ËøõÂ∫¶Êù°Ê†∑Âºè */
.progress-container {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-top: 8px;
}

.progress-bar {
    flex: 1;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
    border-radius: 3px;
    transition: width 0.3s ease;
    position: relative;
}

.progress-fill.completed {
    background: linear-gradient(90deg, #10b981 0%, #059669 100%);
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg,
            transparent 0%,
            rgba(255, 255, 255, 0.2) 50%,
            transparent 100%);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% {
        transform: translateX(-100%);
    }

    100% {
        transform: translateX(100%);
    }
}

.progress-text {
    color: #9ca3af;
    font-size: 12px;
    white-space: nowrap;
    min-width: 80px;
}

.upload-speed {
    color: #6b7280;
}

/* ÈîôËØØ‰ø°ÊÅØÊ†∑Âºè */
.error-message {
    margin-top: 8px;
    padding: 8px;
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-radius: 4px;
    color: #fca5a5;
    font-size: 12px;
}

/* ÊâπÈáèÊìç‰ΩúÊ†∑Âºè */
.batch-actions {
    display: flex;
    gap: 12px;
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.batch-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.upload-all-btn {
    background: #10b981;
    color: white;
}

.upload-all-btn:hover:not(:disabled) {
    background: #059669;
}

.cancel-btn {
    background: #6b7280;
    color: white;
}

.cancel-btn:hover:not(:disabled) {
    background: #4b5563;
}

.batch-btn:disabled {
    background: #374151;
    color: #6b7280;
    cursor: not-allowed;
}

/* ËøáÊ∏°Âä®Áîª */
/* Êñá‰ª∂ÂàóË°®ËøáÊ∏° */
.upload-list-fade-enter-active {
    transition: all 0.4s ease-out;
}

.upload-list-fade-leave-active {
    transition: all 0.3s ease-in;
}

.upload-list-fade-enter-from {
    opacity: 0;
    transform: translateY(20px);
}

.upload-list-fade-leave-to {
    opacity: 0;
    transform: translateY(-10px);
}

/* Êñá‰ª∂È°πËøáÊ∏° */
.file-item-slide-enter-active {
    transition: all 0.4s ease-out;
    transition-delay: var(--delay, 0s);
}

.file-item-slide-leave-active {
    transition: all 0.3s ease-in;
}

.file-item-slide-enter-from {
    opacity: 0;
    transform: translateX(-30px);
}

.file-item-slide-leave-to {
    opacity: 0;
    transform: translateX(30px);
}

/* ËøõÂ∫¶Êù°ËøáÊ∏° */
.progress-fade-enter-active {
    transition: all 0.3s ease-out;
}

.progress-fade-leave-active {
    transition: all 0.2s ease-in;
}

.progress-fade-enter-from {
    opacity: 0;
    transform: scaleY(0);
    transform-origin: top;
}

.progress-fade-leave-to {
    opacity: 0;
    transform: scaleY(0);
    transform-origin: top;
}

/* ÈîôËØØ‰ø°ÊÅØËøáÊ∏° */
.error-slide-enter-active {
    transition: all 0.3s ease-out;
}

.error-slide-leave-active {
    transition: all 0.2s ease-in;
}

.error-slide-enter-from {
    opacity: 0;
    transform: translateY(-10px);
}

.error-slide-leave-to {
    opacity: 0;
    transform: translateY(-10px);
}
</style>